// --- ESP32_SPI_BLE_Gamepad.ino ---

#include <Arduino.h>
#include <BleGamepad.h>
#include <BleGamepadConfiguration.h>
#include <driver/spi_slave.h>
#include <soc/spi_periph.h>

// === CONFIGURATION ===
// Must match Arduino's PACKET_SIZE and ordering.
static const int NUM_BUTTONS   = 32;                        
static const int BUTTON_BYTES  = (NUM_BUTTONS + 7) / 8;    
static const int PACKET_SIZE   = BUTTON_BYTES + 13;         

// SPI Slave pins (must match wiring):
static const int PIN_MISO = 19;
static const int PIN_MOSI = 23;
static const int PIN_SCK  = 18;
static const int PIN_SS   = 5;

// BLE Gamepad objects
BleGamepadConfiguration bleConfig;
BleGamepad           bleGamepad("Pinball_Controller", "VirtualPinball", 100);

// Steam Controller button mapping (physical button index -> Steam Controller button)
// Steam Controller buttons: A=1, B=2, X=3, Y=4, LB=5, RB=6, LT=7, RT=8, Back=9, Start=10, DPad Up=11, Down=12, Left=13, Right=14
static const int steamButtonMap[NUM_BUTTONS] = {
  6,  8,  5,  7,  4,  1,  3,  2,  10, 10, // 0-9:   0=RB, 1=RT, 2=LB, 3=LT, 4=Y, 5=A, 6=X, 7=B, 8=Start
  11, 12, 13, 14, 15, 16, 17, 18, 19, 20, // 10-19
  21, 22, 23, 23, 13, 14, 11, 12, 9,  29, // 20-29: 24=Left, 25=Right, 26=Up, 27=Down, 28=Back
  31, 32                                   // 30-31
};

// Buffers for SPI payload:
uint8_t spiRxBuf[PACKET_SIZE];
uint8_t spiTxBuf[PACKET_SIZE];

void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("ESP32: SPI Slave + BLE Gamepad Starting...");

  // --- 1) Configure and start BLE Gamepad ---
  bleConfig.setButtonCount(NUM_BUTTONS);
  bleConfig.setHatSwitchCount(0);
  // Enable X, Y, RY axes:
  bleConfig.setWhichAxes(true, true, false,   // X, Y, Z
                         false, true, false,  // Rx, Ry, Rz
                         false, false);       // Slider1, Slider2
  // (Leave all simulation controls off; auto-report defaults to true)
  bleGamepad.begin(&bleConfig);

  // --- 2) Prepare SPI slave configuration ---
  spi_bus_config_t         busCfg;
  spi_slave_interface_config_t slaveCfg;

  // Zero everything out
  memset(&busCfg,   0, sizeof(busCfg));
  memset(&slaveCfg, 0, sizeof(slaveCfg));

  // Fill in busCfg fields in declaration order
  busCfg.miso_io_num    = PIN_MISO;
  busCfg.mosi_io_num    = PIN_MOSI;
  busCfg.sclk_io_num    = PIN_SCK;
  busCfg.quadwp_io_num  = -1;
  busCfg.quadhd_io_num  = -1;
  busCfg.max_transfer_sz = PACKET_SIZE;

  // Fill in slaveCfg fields in declaration order
  slaveCfg.spics_io_num  = PIN_SS;
  slaveCfg.flags         = 0;
  slaveCfg.queue_size    = 1;
  slaveCfg.post_setup_cb = nullptr;
  slaveCfg.post_trans_cb = nullptr;

  // 3) Initialize SPI in slave mode
  esp_err_t ret = spi_slave_initialize(VSPI_HOST, &busCfg, &slaveCfg, 0);
  if (ret != ESP_OK) {
    Serial.printf("Failed to init SPI slave: %d\n", ret);
    while (1) { delay(1000); }
  }

  // Zero the buffers
  memset(spiRxBuf, 0, PACKET_SIZE);
  memset(spiTxBuf, 0, PACKET_SIZE);

  delay(100);
  Serial.println("ESP32: Ready to receive SPI data and advertise as BLE Gamepad.");
}

void loop() {
  // 1) Prepare and execute SPI transaction
  spi_slave_transaction_t t;
  memset(&t, 0, sizeof(t));
  t.length    = PACKET_SIZE * 8;  // bits
  t.tx_buffer = spiTxBuf;
  t.rx_buffer = spiRxBuf;

  if (spi_slave_transmit(VSPI_HOST, &t, portMAX_DELAY) != ESP_OK) {
    //Serial.println("SPI receive failed");
    return;
  }

  // 2) Count pressed buttons and validate against sent count
  int pressedCount = 0;
  for (int i = 0; i < NUM_BUTTONS && i < 32; i++) {
    if ((spiRxBuf[i / 8] & (1 << (i % 8))) != 0) {
      pressedCount++;
    }
  }
  
  // 3) Validate packet using button count and checksum
  if (PACKET_SIZE > 16) {
    
    // uint8_t expectedCount = spiRxBuf[16];
    // if (pressedCount != expectedCount) {
    //   // Button count mismatch - corrupted packet, skip processing
    //   Serial.println("Button count validation failed");
    //   return;
    // }
    
    // Validate checksum
    uint8_t calculatedChecksum = 0;
    for (int i = 0; i < PACKET_SIZE - 1; i++) {
      calculatedChecksum ^= spiRxBuf[i];
    }
    if (calculatedChecksum != spiRxBuf[PACKET_SIZE - 1]) {
      // Checksum mismatch - corrupted packet, skip processing
      //Serial.println("Checksum validation failed");
      return;
    }
  }
  
  // 4) Update buttons using Steam Controller mapping
  for (int i = 0; i < NUM_BUTTONS; i++) {
    bool pressed = (spiRxBuf[i / 8] & (1 << (i % 8))) != 0;
    if (pressed) {
      bleGamepad.press(steamButtonMap[i]);
    } else {
      bleGamepad.release(steamButtonMap[i]);
    }
  }

  // 5) Parse and validate duplicate analog values
  int16_t plunger1 = (spiRxBuf[4] << 8) | spiRxBuf[5];
  int16_t xAxis1   = (spiRxBuf[6] << 8) | spiRxBuf[7];
  int16_t yAxis1   = (spiRxBuf[8] << 8) | spiRxBuf[9];
  
  int16_t plunger2 = (spiRxBuf[10] << 8) | spiRxBuf[11];
  int16_t xAxis2   = (spiRxBuf[12] << 8) | spiRxBuf[13];
  int16_t yAxis2   = (spiRxBuf[14] << 8) | spiRxBuf[15];
  
  // Validate that duplicate values match
  if (plunger1 != plunger2 || xAxis1 != xAxis2 || yAxis1 != yAxis2) {
    // Analog value mismatch - corrupted packet, skip processing
    //Serial.println("Analog value validation failed");
    return;
  }
  
  // Use the validated values
  int16_t plunger = plunger1;
  int16_t xAxis = xAxis1;
  int16_t yAxis = yAxis1;

  // 6) Fast conversion from signed to unsigned range
  int16_t xAxisCentered = (xAxis >> 1) + 16384;  // Faster than map()
  int16_t yAxisCentered = (yAxis >> 1) + 16384;

  // 7) Fast conversion from signed to unsigned range (same pattern as accelerometer)
  int16_t plungerScaled = (plunger << 7) + 16384;  // Scale 8-bit signed, center at 16384 like accel
  
  // Debug logging for plunger values
  Serial.printf("Plunger Debug: Raw1=%d Raw2=%d Final=%d Scaled=%d\n", 
                plunger1, plunger2, plunger, plungerScaled);
  
  // 8) Update axes (X, Y, Z, RX, RY, RZ, Slider1, Slider2)
  bleGamepad.setAxes(xAxisCentered, yAxisCentered, 0, 0, plungerScaled, 0, 0, 0);

  // 9) Send the HID report if connected
  if (bleGamepad.isConnected()) {
    bleGamepad.sendReport();
  }

  // (Uncomment for debug output)
  /*
  Serial.printf("Btns:");
  for (int i = 0; i < NUM_BUTTONS; i++) {
    Serial.print((spiRxBuf[i/8] & (1 << (i%8))) ? '1' : '0');
  }
  Serial.printf("  RY=%d X=%d Y=%d\n", plunger, xAxis, yAxis);
  */
}
